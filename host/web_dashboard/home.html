<!DOCTYPE html>
<html data-bs-theme="dark">

<head>
    <title>NHP Synth Home</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=800, height=480, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="stylesheet" href="static/css/bootstrap.min.css">
    <script src="static/js/socket.io.min.js"></script>
    <script src="static/js/bootstrap.bundle.min.js"></script>
    <script src="static/js/chart.umd.min.js"></script>
</head>

<body>
    <script type="module">
        import {
            apiPost,
            setSynthAmplitude,
            setSynthFrequency,
            setSynthPhase,
            setSynthHarmonics,
            sendSynthCommand,
            synthStateEquals
        } from './static/js/api.js';

        import {
            CombinedWaveformChart,
            renderHarmonics,
            SynthAccordionItem,
            SynthCardsRow,
            LoadingSpinner
        } from './static/js/components.js';


        // --- State & Formatting ---
        const AppState = {
            synthstate: null,
        };

        // --- Offcanvas Increment/Decrement Handlers ---
        // These will be attached to window so they can be called from inline HTML
        window.incrementVoltage = async function(idx, delta) {
            if (!AppState.synthstate || !AppState.synthstate.synths || !AppState.synthstate.synths[idx]) {
                console.error('incrementVoltage: synth is undefined for idx', idx);
                return;
            }
            const synth = AppState.synthstate.synths[idx];
            if (typeof synth.id === 'undefined') {
                console.error('incrementVoltage: synth.id is undefined for idx', idx, synth);
                return;
            }
            const VOLTAGE_RMS_MAX = 240;
            let value = (synth.amplitude_a / 100) * VOLTAGE_RMS_MAX + delta;
            value = Math.max(0, Math.min(VOLTAGE_RMS_MAX, value));
            // Convert back to percent
            const percent = +(value / VOLTAGE_RMS_MAX * 100).toFixed(2);
            await setSynthAmplitude(synth.id, 'a', percent);
        };
        // Direct set handler for voltage
        window.setVoltageDirect = async function(idx, value) {
            if (!AppState.synthstate || !AppState.synthstate.synths || !AppState.synthstate.synths[idx]) {
                console.error('setVoltageDirect: synth is undefined for idx', idx);
                return;
            }
            const synth = AppState.synthstate.synths[idx];
            if (typeof synth.id === 'undefined') {
                console.error('setVoltageDirect: synth.id is undefined for idx', idx, synth);
                return;
            }
            const VOLTAGE_RMS_MAX = 240;
            let v = parseFloat(value);
            if (isNaN(v)) return;
            v = Math.max(0, Math.min(VOLTAGE_RMS_MAX, v));
            const percent = +(v / VOLTAGE_RMS_MAX * 100).toFixed(2);
            await setSynthAmplitude(synth.id, 'a', percent);
        };
        window.incrementCurrent = async function(idx, delta) {
            if (!AppState.synthstate || !AppState.synthstate.synths || !AppState.synthstate.synths[idx]) {
                console.error('incrementCurrent: synth is undefined for idx', idx);
                return;
            }
            const synth = AppState.synthstate.synths[idx];
            if (typeof synth.id === 'undefined') {
                console.error('incrementCurrent: synth.id is undefined for idx', idx, synth);
                return;
            }
            const CURRENT_RMS_MAX = 10;
            let value = (synth.amplitude_b / 100) * CURRENT_RMS_MAX + delta;
            value = Math.max(0, Math.min(CURRENT_RMS_MAX, value));
            const percent = +(value / CURRENT_RMS_MAX * 100).toFixed(2);
            await setSynthAmplitude(synth.id, 'b', percent);
        };
        // Direct set handler for current
        window.setCurrentDirect = async function(idx, value) {
            if (!AppState.synthstate || !AppState.synthstate.synths || !AppState.synthstate.synths[idx]) {
                console.error('setCurrentDirect: synth is undefined for idx', idx);
                return;
            }
            const synth = AppState.synthstate.synths[idx];
            if (typeof synth.id === 'undefined') {
                console.error('setCurrentDirect: synth.id is undefined for idx', idx, synth);
                return;
            }
            const CURRENT_RMS_MAX = 10;
            let v = parseFloat(value);
            if (isNaN(v)) return;
            v = Math.max(0, Math.min(CURRENT_RMS_MAX, v));
            const percent = +(v / CURRENT_RMS_MAX * 100).toFixed(2);
            await setSynthAmplitude(synth.id, 'b', percent);
        };
        window.incrementPhase = async function(idx, delta) {
            if (!AppState.synthstate || !AppState.synthstate.synths || !AppState.synthstate.synths[idx]) {
                console.error('incrementPhase: synth is undefined for idx', idx);
                return;
            }
            const synth = AppState.synthstate.synths[idx];
            if (typeof synth.id === 'undefined') {
                console.error('incrementPhase: synth.id is undefined for idx', idx, synth);
                return;
            }
            let value = synth.phase_a + delta;
            value = ((value % 360) + 360) % 360;
            value = +value.toFixed(2);
            await setSynthPhase(synth.id, 'a', value);
        };
        // Direct set handler for phase
        window.setPhaseDirect = async function(idx, value) {
            if (!AppState.synthstate || !AppState.synthstate.synths || !AppState.synthstate.synths[idx]) {
                console.error('setPhaseDirect: synth is undefined for idx', idx);
                return;
            }
            const synth = AppState.synthstate.synths[idx];
            if (typeof synth.id === 'undefined') {
                console.error('setPhaseDirect: synth.id is undefined for idx', idx, synth);
                return;
            }
            let v = parseFloat(value);
            if (isNaN(v)) return;
            v = ((v % 360) + 360) % 360;
            v = +v.toFixed(2);
            await setSynthPhase(synth.id, 'a', v);
        };
        window.incrementFrequency = async function(idx, delta) {
            if (!AppState.synthstate || !AppState.synthstate.synths || !AppState.synthstate.synths[idx]) {
                console.error('incrementFrequency: synth is undefined for idx', idx);
                return;
            }
            const synth = AppState.synthstate.synths[idx];
            if (typeof synth.id === 'undefined') {
                console.error('incrementFrequency: synth.id is undefined for idx', idx, synth);
                return;
            }
            let value = synth.frequency_a + delta * 1;
            value = Math.max(0, value);
            value = +value.toFixed(2);
            await setSynthFrequency(synth.id, 'a', value);
        };
        // Direct set handler for frequency
        window.setFrequencyDirect = async function(idx, value) {
            if (!AppState.synthstate || !AppState.synthstate.synths || !AppState.synthstate.synths[idx]) {
                console.error('setFrequencyDirect: synth is undefined for idx', idx);
                return;
            }
            const synth = AppState.synthstate.synths[idx];
            if (typeof synth.id === 'undefined') {
                console.error('setFrequencyDirect: synth.id is undefined for idx', idx, synth);
                return;
            }
            let v = parseFloat(value);
            if (isNaN(v)) return;
            v = Math.max(0, v);
            v = +v.toFixed(2);
            await setSynthFrequency(synth.id, 'a', v);
        };


        // --- Accordion & Offcanvas State Persistence ---
        AppState.openAccordionId = null;
        AppState.openOffcanvasId = null;

        // Listen for accordion and offcanvas open/close events
        function setupAccordionListeners() {
            const accordion = document.getElementById('synthAccordion');
            if (accordion) {
                accordion.querySelectorAll('.accordion-collapse').forEach(collapse => {
                    collapse.addEventListener('show.bs.collapse', function () {
                        AppState.openAccordionId = this.id;
                    });
                    collapse.addEventListener('hide.bs.collapse', function () {
                        if (AppState.openAccordionId === this.id) {
                            AppState.openAccordionId = null;
                        }
                    });
                });
            }
            // Offcanvas listeners
            document.querySelectorAll('.offcanvas').forEach(offcanvas => {
                offcanvas.addEventListener('show.bs.offcanvas', function () {
                    AppState.openOffcanvasId = this.id;
                });
                offcanvas.addEventListener('hide.bs.offcanvas', function () {
                    if (AppState.openOffcanvasId === this.id) {
                        AppState.openOffcanvasId = null;
                    }
                });
            });
        }

        // --- Render Logic ---
        function render() {
            // Synth cards
            const cardsRow = document.getElementById('synth-cards-row');
            if (cardsRow) {
                if (AppState.synthstate && AppState.synthstate.synths) {
                    cardsRow.innerHTML = SynthCardsRow(AppState);
                    // After DOM update, render combined waveforms for each synth
                    AppState.synthstate.synths.forEach((synth, idx) => {
                        CombinedWaveformChart(synth, `waveform_combined_${idx}`);
                    });
                    // Restore open accordion if any, but only disable animation for this restoration
                    if (AppState.openAccordionId) {
                        const openElem = document.getElementById(AppState.openAccordionId);
                        if (openElem && !openElem.classList.contains('show')) {
                            // Temporarily disable transition for this element
                            const prevTransition = openElem.style.transition;
                            openElem.style.transition = 'none';
                            openElem.classList.add('show');
                            // Force reflow to apply the class immediately
                            void openElem.offsetWidth;
                            // Restore transition after a short delay
                            setTimeout(() => {
                                openElem.style.transition = prevTransition;
                            }, 10);
                        }
                    }
                    setupAccordionListeners();
                    // Restore open offcanvas if any, but only disable animation for this restoration
                    if (AppState.openOffcanvasId) {
                        const offcanvasElem = document.getElementById(AppState.openOffcanvasId);
                        if (offcanvasElem && !offcanvasElem.classList.contains('show')) {
                            // Temporarily disable transition for this element
                            const prevTransition = offcanvasElem.style.transition;
                            offcanvasElem.style.transition = 'none';
                            // Use Bootstrap's Offcanvas API to show
                            const bsOffcanvas = bootstrap.Offcanvas.getOrCreateInstance(offcanvasElem);
                            bsOffcanvas.show();
                            // Force reflow to apply the class immediately
                            void offcanvasElem.offsetWidth;
                            // Restore transition after a short delay
                            setTimeout(() => {
                                offcanvasElem.style.transition = prevTransition;
                            }, 10);
                        }
                    }
                } else {
                    cardsRow.innerHTML = LoadingSpinner();
                }
            }
        }

        // --- Socket.IO and Event Logic ---
        const socket = io();
        socket.on('synth_state', function (data) {
            if (!synthStateEquals(AppState.synthstate, data)) {
                // Assign synthetic id if missing
                if (data && Array.isArray(data.synths)) {
                    data.synths.forEach((synth, idx) => {
                        if (typeof synth.id === 'undefined') {
                            synth.id = idx;
                        }
                    });
                }
                AppState.synthstate = data;
                render();
            }
        });

        document.addEventListener('DOMContentLoaded', function () {
            render();
            const fsBtn = document.getElementById('fullscreen-btn');
            if (fsBtn) {
                fsBtn.addEventListener('click', toggleFullscreen);
            }
            // Optionally update icon/text on fullscreen change
            function updateFullscreenIcon() {
                const icon = document.getElementById('fullscreen-icon');
                if (!icon) return;
                if (document.fullscreenElement) {
                    icon.innerHTML = '&#x2715;'; // X for exit
                } else {
                    icon.innerHTML = '&#x26F6;'; // Diagonal arrow for enter
                }
            }
            document.addEventListener('fullscreenchange', updateFullscreenIcon);
            document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);
            document.addEventListener('mozfullscreenchange', updateFullscreenIcon);
            document.addEventListener('MSFullscreenChange', updateFullscreenIcon);
        });

        // --- Fullscreen Toggle Logic ---
        function toggleFullscreen() {
            const doc = window.document;
            const docEl = doc.documentElement;
            if (!doc.fullscreenElement && !doc.webkitFullscreenElement && !doc.mozFullScreenElement && !doc.msFullscreenElement) {
                if (docEl.requestFullscreen) {
                    docEl.requestFullscreen();
                } else if (docEl.mozRequestFullScreen) {
                    docEl.mozRequestFullScreen();
                } else if (docEl.webkitRequestFullscreen) {
                    docEl.webkitRequestFullscreen();
                } else if (docEl.msRequestFullscreen) {
                    docEl.msRequestFullscreen();
                }
            } else {
                if (doc.exitFullscreen) {
                    doc.exitFullscreen();
                } else if (doc.mozCancelFullScreen) {
                    doc.mozCancelFullScreen();
                } else if (doc.webkitExitFullscreen) {
                    doc.webkitExitFullscreen();
                } else if (doc.msExitFullscreen) {
                    doc.msExitFullscreen();
                }
            }
        }
        </script>
    <div class="d-flex justify-content-center align-items-center min-vh-100">
        <div class="container-fluid bg-secondary rounded shadow overflow-hidden" style="width:800px; height:480px;">
            <div class="row bg-dark mb-2 align-items-center" style="min-height:38px;">
                <div class="col text-end">
                    <button class="btn btn-sm btn-outline-light me-2" onclick="window.location.reload()" title="Force Refresh">
                        &#x21bb; Refresh
                    </button>
                    <button class="btn btn-sm btn-outline-light" id="fullscreen-btn" title="Toggle Fullscreen">
                        <span id="fullscreen-icon">&#x26F6;</span> Fullscreen
                    </button>
                </div>
            </div>
            <!-- Left panel: synth cards -->
            <div class="row h-100">
                <div class="col-6 h-100 pe-1">

                    <div class="row flex-nowrap overflow-auto h-100" id="synth-cards-row" style="min-height:340px;">
                        <!-- Synth cards will be dynamically inserted here -->
                    </div>
                </div>
                <!-- Right panel: blank for now -->
                <div class="col-6 h-100 ps-1">
                    <div class="card rounded">
                        <div class="card-header bg-dark text-light text-center py-2">
                            <strong>Right Panel</strong>
                        </div>
                        <div class="card-body d-flex flex-column justify-content-center align-items-center">
                            <p class="text-muted">This panel is reserved for future content.</p>
                        </div>
                    </div>
                    <!-- Placeholder for future content -->
                </div>
            </div>
        </div>
    </div>
</body>

</html>