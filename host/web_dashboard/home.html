<!DOCTYPE html>
<html data-bs-theme="dark">

<head>
    <title>NHP Synth Home</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=800, height=480, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="stylesheet" href="static/css/bootstrap.min.css">
    <link rel="stylesheet" href="static/css/bootstrap-icons-1.11.0/bootstrap-icons.css">
    <script src="static/js/socket.io.min.js"></script>
    <script src="static/js/bootstrap.bundle.min.js"></script>
    <script src="static/js/chart.umd.min.js"></script>
</head>

<body>
    <script type="module">
        import {
            apiPost,
            setSynthAmplitude,
            setSynthFrequency,
            setSynthPhase,
            setSynthHarmonics,
            sendSynthCommand,
            synthStateEquals,
            setSocket
        } from './static/js/api.js';

        import {
            CombinedWaveformChart,
            renderHarmonics,
            SynthAccordionItem,
            SynthCardsRow,
            LoadingSpinner
        } from './static/js/components.js';

        import {
            AppState,
            setSynthState,
            setOpenAccordionId,
            setOpenOffcanvasId,
            setSelectedId,
            getSynthState,
            getOpenAccordionId,
            getOpenOffcanvasId,
            getSelectedId
        } from './static/js/state.js';

        import {
            incrementVoltage,
            setVoltageDirect,
            resetVoltage,
            incrementCurrent,
            setCurrentDirect,
            resetCurrent,
            incrementPhase,
            setPhaseDirect,
            resetPhase,
            incrementFrequency,
            setFrequencyDirect,
            resetFrequency,
            incrementHarmonicOrder
        } from './static/js/synthHandlers.js';

        window.incrementVoltage = incrementVoltage;
        window.setVoltageDirect = setVoltageDirect;
        window.resetVoltage = resetVoltage;
        window.incrementCurrent = incrementCurrent;
        window.setCurrentDirect = setCurrentDirect;
        window.resetCurrent = resetCurrent;
        window.incrementPhase = incrementPhase;
        window.setPhaseDirect = setPhaseDirect;
        window.resetPhase = resetPhase;
        window.incrementFrequency = incrementFrequency;
        window.setFrequencyDirect = setFrequencyDirect;
        window.resetFrequency = resetFrequency;
        window.incrementHarmonicOrder = incrementHarmonicOrder;

        // --- Accordion & Offcanvas State Persistence ---
        setOpenAccordionId(null);
        setOpenOffcanvasId(null);
        setSelectedId(null);

        // Listen for accordion and offcanvas open/close events
        function setupStateListeners() {
            const accordion = document.getElementById('synthAccordion');
            accordion.querySelectorAll('.accordion-collapse').forEach(collapse => {
                collapse.addEventListener('show.bs.collapse', function () {
                    setOpenAccordionId(this.id);
                });
                collapse.addEventListener('hide.bs.collapse', function () {
                    if (getOpenAccordionId() === this.id) {
                        setOpenAccordionId(null);
                    }
                });
            });

            // Offcanvas listeners
            document.querySelectorAll('.offcanvas').forEach(offcanvas => {
                offcanvas.addEventListener('show.bs.offcanvas', function () {
                    setOpenOffcanvasId(this.id);
                });
                offcanvas.addEventListener('hide.bs.offcanvas', function () {
                    if (getOpenOffcanvasId() === this.id) {
                        setOpenOffcanvasId(null);
                    }
                });
            });

            // Input group selection listeners
            document.querySelectorAll('.selectable').forEach(element => {
                element.addEventListener('click', function () {
                    const currentId = getSelectedId();
                    if (currentId === this.id) {
                        setSelectedId(null); // Deselect if already selected
                    } else {
                        setSelectedId(this.id); // Select this group
                        // Deselect other groups
                        document.querySelectorAll('.selectable').forEach(otherSelectable => {
                            if (otherSelectable !== this) {
                                otherSelectable.classList.remove('selected');
                            }
                        });
                        this.classList.add('selected');
                    }
                });
            });
        }

        // --- Render Logic ---
        function render() {
            // Synth cards
            const cardsRow = document.getElementById('synth-cards-row');
            if (cardsRow) {
                if (AppState.synthState && AppState.synthState.synths) {
                    cardsRow.innerHTML = SynthCardsRow(AppState);
                    // After DOM update, render combined waveforms for each synth
                    AppState.synthState.synths.forEach((synth, idx) => {
                        CombinedWaveformChart(synth, `waveform_combined_${idx}`);
                    });
                    console.log(AppState);

                    // Restore open accordion if any, but only disable animation for this restoration
                    if (AppState.openAccordionId) {
                        const openElem = document.getElementById(AppState.openAccordionId);
                        if (openElem && !openElem.classList.contains('show')) {
                            // Temporarily disable transition for this element
                            const prevTransition = openElem.style.transition;
                            openElem.style.transition = 'none';
                            openElem.classList.add('show');
                            // Force reflow to apply the class immediately
                            void openElem.offsetWidth;
                            // Restore transition after a short delay
                            setTimeout(() => {
                                openElem.style.transition = prevTransition;
                            }, 10);
                        }
                    }

                    // Restore selected input group if any
                    if (AppState.selectedId) {
                        const selectedId = document.getElementById(AppState.selectedId);
                        if (selectedId) {
                            selectedId.classList.add('selected');
                        }
                    }

                    // Restore open offcanvas if any, but only disable animation for this restoration
                    if (AppState.openOffcanvasId) {
                        const offcanvasElem = document.getElementById(AppState.openOffcanvasId);
                        if (offcanvasElem && !offcanvasElem.classList.contains('show')) {
                            // Temporarily disable transition for this element
                            const prevTransition = offcanvasElem.style.transition;
                            offcanvasElem.style.transition = 'none';
                            // Use Bootstrap's Offcanvas API to show
                            const bsOffcanvas = bootstrap.Offcanvas.getOrCreateInstance(offcanvasElem);
                            bsOffcanvas.show();
                            // Force reflow to apply the class immediately
                            void offcanvasElem.offsetWidth;
                            // Restore transition after a short delay
                            setTimeout(() => {
                                offcanvasElem.style.transition = prevTransition;
                            }, 10);
                        }
                    }

                    setupStateListeners();
                } else {
                    cardsRow.innerHTML = LoadingSpinner();
                }
            }
        }

        // --- Socket.IO and Event Logic ---
        const socket = io();
        setSocket(socket);
        socket.on('synthState', function (data) {
            if (!synthStateEquals(AppState.synthState, data)) {
                // Assign synthetic id if missing
                if (data && Array.isArray(data.synths)) {
                    data.synths.forEach((synth, idx) => {
                        if (typeof synth.id === 'undefined') {
                            synth.id = idx;
                        }
                    });
                }
                AppState.synthState = data;
                render();
            }
        });

        document.addEventListener('DOMContentLoaded', function () {
            render();
            const fsBtn = document.getElementById('fullscreen-btn');
            if (fsBtn) {
                fsBtn.addEventListener('click', toggleFullscreen);
            }
            // Optionally update icon/text on fullscreen change
            function updateFullscreenIcon() {
                const icon = document.getElementById('fullscreen-icon');
                if (!icon) return;
                if (document.fullscreenElement) {
                    icon.innerHTML = '<span class="bi bi-fullscreen-exit"></span>'; // Exit fullscreen icon
                } else {
                    icon.innerHTML = '<span class="bi bi-fullscreen"></span>'; // Fullscreen icon
                }
            }
            document.addEventListener('fullscreenchange', updateFullscreenIcon);
            document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);
            document.addEventListener('mozfullscreenchange', updateFullscreenIcon);
            document.addEventListener('MSFullscreenChange', updateFullscreenIcon);
        });

        // --- Fullscreen Toggle Logic ---
        function toggleFullscreen() {
            const doc = window.document;
            const docEl = doc.documentElement;
            if (!doc.fullscreenElement && !doc.webkitFullscreenElement && !doc.mozFullScreenElement && !doc.msFullscreenElement) {
                if (docEl.requestFullscreen) {
                    docEl.requestFullscreen();
                } else if (docEl.mozRequestFullScreen) {
                    docEl.mozRequestFullScreen();
                } else if (docEl.webkitRequestFullscreen) {
                    docEl.webkitRequestFullscreen();
                } else if (docEl.msRequestFullscreen) {
                    docEl.msRequestFullscreen();
                }
            } else {
                if (doc.exitFullscreen) {
                    doc.exitFullscreen();
                } else if (doc.mozCancelFullScreen) {
                    doc.mozCancelFullScreen();
                } else if (doc.webkitExitFullscreen) {
                    doc.webkitExitFullscreen();
                } else if (doc.msExitFullscreen) {
                    doc.msExitFullscreen();
                }
            }
        }
    </script>
    <div class="d-flex justify-content-center align-items-center min-vh-100">
        <div class="container-fluid bg-secondary rounded shadow overflow-hidden" style="width:800px; height:480px;">
            <div class="row bg-dark mb-2 align-items-center" style="min-height:38px;">
                <div class="col text-end">
                    <button class="btn btn-sm btn-outline-light me-2" onclick="window.location.reload()"
                        title="Force Refresh">
                        <span class="bi bi-arrow-clockwise"></span>
                    </button>
                    <button class="btn btn-sm btn-outline-light" id="fullscreen-btn" title="Toggle Fullscreen">
                        <span id="fullscreen-icon"><span class="bi bi-fullscreen"></span></span>
                    </button>
                </div>
            </div>
            <!-- Left panel: synth cards -->
            <div class="row h-100">
                <div class="col-6 h-100 pe-1">

                    <div class="row flex-nowrap overflow-auto h-100" id="synth-cards-row" style="min-height:340px;">
                        <!-- Synth cards will be dynamically inserted here -->
                    </div>
                </div>
                <!-- Right panel: blank for now -->
                <div class="col-6 h-100 ps-1">
                    <div class="card rounded">
                        <div class="card-header bg-dark text-light text-center py-2">
                            <strong>Right Panel</strong>
                        </div>
                        <div class="card-body d-flex flex-column justify-content-center align-items-center">
                            <p class="text-muted">This panel is reserved for future content.</p>
                        </div>
                    </div>
                    <!-- Placeholder for future content -->
                </div>
            </div>
        </div>
    </div>
</body>

</html>